% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{javautil-dblogging Documentation}
\date{October 27, 2019}
\release{19.6.0}
\author{Jim Schmidt}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Application instrumentation is essential to performance monitoring,
unfortunately this is often performed by throwing in some logging
statements using a java logging framework or wrapper, such as slf,

This however fails to capture any information essential to end-to-end
monitoring as it omits what is generally the biggest source of latency,
the relational database. What statements are being executed, how long do
they take, which statements take up the bulk of the resources in
aggreggate (an umder-performing statement invoked thousands of times an
hour is not uncommon).

Oracle provides, at great expense, the ASH subystem and even that does
not associated the sql statements to the application code.

This utility provides a simple Application Program Interface to allow
you to record performance information in a simple, low overhead fashion
from any java program or any program that allows pl/sql calls.

Thus a few judicious additions to an Oracle Form or a batch job can
provide the foundation of information necessary to establish where
database resources are being consumed.

Resolution of these matters is a different matter and may involve
gathering statistics, altering execution plans, creating or eliminating
indexes or rewriing SQL.

SGA paramaters may have to be changed.


\chapter{Document Organization}
\label{index:dblogging-2019-10-16}\label{index:document-organization}
We will introduce the types of logging, show examples of how to
instrument your code and what type of output is generated.

Then we will guide you through the installation and options.


\chapter{Overview of logging types}
\label{index:overview-of-logging-types}

\section{Flat file logging}
\label{index:flat-file-logging}
Writes log messages to a text file on the database server.

Includes:
\begin{itemize}
\item {} 
log\_seq\_nbr

\item {} 
log\_level

\item {} 
job\_log\_id

\item {} 
log\_msg\_id

\item {} 
line\_number

\item {} 
current\_timestamp, `YYYY-MM-DDTHH24:MI:SSXFF'

\item {} 
log\_msg

\item {} 
caller\_name optional

\item {} 
call\_stack optional

\end{itemize}

This will allow you to easily write log messages from pl/sql in stored
procedures, functions, packages and with most of the flexibility and
ease of using a java logging framework.


\subsection{Logging to flat files}
\label{flatFile::doc}\label{flatFile:logging-to-flat-files}

\subsubsection{Overview}
\label{flatFile:overview}
Logs messages using utl\_file to a directory on the database server
specified.

First the database directory is created and oracle is granted permission
to read and write it, then the ddl ``create directory....'' and ``grant
read, write on directory...''


\subsubsection{Examples}
\label{flatFile:examples}

\paragraph{log\_to\_file\_only.proc.sr.sql}
\label{flatFile:log-to-file-only-proc-sr-sql}

\subsubsection{Input}
\label{flatFile:input}
\begin{Verbatim}[commandchars=\\\{\}]
set serveroutput on
set echo on
create or replace procedure log\_to\_file\_only is
       long\_msg clob := 'this is an absurdly long message, ' \textbar{}\textbar{}
                ' interesting stuff to say so I will just write meaningless ' \textbar{}\textbar{}
                ' stuff for a little while. ' \textbar{}\textbar{}
                ' The quick brown fox jumped over the lazy dog. ';

    my\_log\_file\_name varchar(4096);
begin
    my\_log\_file\_name := pllogger.open\_log\_file('log\_to\_file\_only.text');
    pllogger.set\_filter\_level(9); -- all messages should go to log file
    pllogger.info('anonymous',\$\$PLSQL\_LINE,'begin loop');
    pllogger.info(\$\$PLSQL\_UNIT,\$\$PLSQL\_LINE,long\_msg);
    for i in 1..3
    loop
        pllogger.fine(\$\$PLSQL\_UNIT,\$\$PLSQL\_LINE,'i is ' \textbar{}\textbar{} to\_char(i));
    end loop;
    pllogger.close\_log\_file();
exception when others then
        -- a severe condition is not necessarily fatal
    pllogger.severe(\$\$PLSQL\_UINIT,\$\$PLSQL\_LINE,sqlerrm);
    pllogger.close\_log\_file();
    raise;
end;
/
show errors

exec log\_to\_file\_only();
\end{Verbatim}


\subsubsection{Output}
\label{flatFile:output}
\begin{Verbatim}[commandchars=\\\{\}]
"log\_level","job\_log\_id","job\_msg\_id","line\_number","timestamp","log\_msg","caller\_name","call\_stack"
4,,,17,"2019-10-26T17:19:52.885607","begin loop","anonymous",""
4,,,18,"2019-10-26T17:19:52.886020","this is an absurdly long message,  exceeding the length of the log\_msg field  this should be inserted into the log\_msg\_clob column.   This message is part of  a unit test of from sample\_job\_02 of the logging package.   I am running out of  interesting stuff to say so I will just write meaningless  stuff for a little while.  The quick brown fox jumped over the lazy dog. ","LOG\_TO\_FILE\_ONLY",""
7,,,22,"2019-10-26T17:19:52.886197","i is 1","LOG\_TO\_FILE\_ONLY",""
7,,,22,"2019-10-26T17:19:52.886357","i is 2","LOG\_TO\_FILE\_ONLY",""
7,,,22,"2019-10-26T17:19:52.886502","i is 3","LOG\_TO\_FILE\_ONLY",""
\end{Verbatim}


\section{Database Logging}
\label{index:database-logging}
Record jobs and their steps, how long each step took to execute and
optionally extremely detailed information about every database operation
as an oracle trace file may be parsed and stored in the log repository.

The log repository may be on the same oracle database server, even the
same schema using the same connection as it uses autonomous
transactions, or in postgresql or h2.


\subsection{Database Logging}
\label{databaseLogging:database-logging}\label{databaseLogging::doc}
included file


\subsubsection{job\_tables}
\label{databaseLogging:job-tables}
In the interest of expediency we have a quick listing of the job tables.

\begin{Verbatim}[commandchars=\\\{\}]
SQL\textgreater{} describe job\_log
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 JOB\_LOG\_ID                                NOT NULL NUMBER(9)
 SCHEMA\_NAME                                        VARCHAR2(30)
 PROCESS\_NAME                                       VARCHAR2(128)
 THREAD\_NAME                                        VARCHAR2(128)
 STATUS\_MSG                                         VARCHAR2(256)
 STATUS\_TS                                          TIMESTAMP(9)
 END\_TS                                             TIMESTAMP(9)
 ELAPSED\_MILLIS                                     NUMBER(9)
 SID                                                NUMBER
 SERIAL\_NBR                                         NUMBER
 IGNORE\_FLG                                         VARCHAR2(1)
 MODULE\_NAME                                        VARCHAR2(64)
 CLASSNAME                                          VARCHAR2(255)
 TRACEFILE\_NAME                                     VARCHAR2(4000)
 TRACEFILE\_DATA                                     CLOB
 TRACEFILE\_JSON                                     CLOB
 ABORT\_STACKTRACE                                   CLOB

SQL\textgreater{} describe job\_step
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 JOB\_STEP\_ID                               NOT NULL NUMBER(9)
 JOB\_LOG\_ID                                         NUMBER(9)
 STEP\_NAME                                          VARCHAR2(64)
 CLASSNAME                                          VARCHAR2(256)
 STEP\_INFO                                          VARCHAR2(2000)
 START\_TS                                           TIMESTAMP(9)
 END\_TS                                             TIMESTAMP(9)
 DBSTATS                                            CLOB
 STEP\_INFO\_JSON                                     CLOB
 CURSOR\_INFO\_RUN\_ID                                 NUMBER(9)
 STACKTRACE                                         VARCHAR2(4000)

SQL\textgreater{} describe job\_msg;
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 JOB\_MSG\_ID                                         NUMBER(9)
 JOB\_LOG\_ID                                NOT NULL NUMBER(9)
 LOG\_MSG\_ID                                         VARCHAR2(8)
 LOG\_MSG                                            VARCHAR2(256)
 LOG\_MSG\_CLOB                                       CLOB
 LOG\_MSG\_TS                                         TIMESTAMP(9)
 ELAPSED\_TIME\_MILLISECONDS                          NUMBER(9)
 LOG\_SEQ\_NBR                               NOT NULL NUMBER(18)
 CALLER\_NAME                                        VARCHAR2(100)
 LINE\_NBR                                           NUMBER(5)
 CALL\_STACK                                         CLOB
 LOG\_LEVEL                                          NUMBER(2)
\end{Verbatim}


\subsubsection{Entity Relationship Diagram}
\label{databaseLogging:entity-relationship-diagram}\begin{figure}[htbp]
\centering

\includegraphics{job_tables_erd.png}
\end{figure}

TODO run the python with the comments

Each job has one job\_log entry and one or more job\_steps.

Job steps may have associated log messages.


\paragraph{dblogger\_install\_tables}
\label{databaseLogging:dblogger-install-tables}
Creates the job and job step tables and views


\subparagraph{sequences}
\label{databaseLogging:sequences}
cursor\_info\_run\_id\_seq; cursor\_info\_id\_seq; job\_log\_id\_seq;
job\_msg\_id\_seq; job\_step\_id\_seq;


\subparagraph{tables}
\label{databaseLogging:tables}\begin{itemize}
\item {} 
cursor\_explain\_plan

\item {} 
cursor\_sql\_text

\item {} 
cursor\_info\_run

\item {} 
cursor\_info

\item {} 
cursor\_stat

\item {} 
job\_log

\item {} 
job\_msg

\item {} 
job\_step

\end{itemize}


\subparagraph{views}
\label{databaseLogging:views}\begin{itemize}
\item {} 
cursor\_info\_vw

\item {} 
job\_step\_vw

\item {} 
job\_log\_vw

\end{itemize}


\paragraph{Job Logging}
\label{databaseLogging:job-logging}
Logging information may be written to a text file, stored in a database
and written to the oracle trace file.


\subsubsection{Steps start job logging.}
\label{databaseLogging:steps-start-job-logging}
\begin{Verbatim}[commandchars=\\\{\}]
public long sampleUsage(Dblogger dblogger, Connection appConnection) throws SqlSplitterException, Exception \PYGZob{}
    dblogger.prepareConnection();
    final String processName = "Process Name";
    // Start the job

    final long logJobId = dblogger.startJobLogging(processName,getClass().getName(), null, null,  4);
    dblogger.setModule("SplitLoggerTest", "simple example");
    dblogger.setAction("Some work");
    dblogger.insertStep("Full join", "Meaningless busy work", getClass().getName());
    ConnectionUtil.exhaustQuery(appConnection, "select * from user\_tab\_columns, user\_tables where rownum \textless{} 100");

    dblogger.setAction("Another set of work");
    ConnectionUtil.exhaustQuery(appConnection, "select count(*) from all\_tab\_columns");
    // End the job
    dblogger.endJob();
    return logJobId;
\PYGZcb{}
\end{Verbatim}

job logging persistence has a bit of indirection


\paragraph{Installation}
\label{databaseLogging:installation}

\subsubsection{Repositories}
\label{databaseLogging:repositories}
RDBMS persistence support is provided for Oracle, H2 and postgresql

H2 is a lightweight database and may be used to eliminate the need for
support of another Oracle Database.

Postgresql is a high end database that requires minimimal installation
and administration.

You should probable not compound your problem with yet another Oracle
install, but if your DBA will allow you a schema in your database for
logging, you don't have to learn anything else.

The Oracle database could be the same instance as the application being
monitored, but this may raise some objections to the application DBA.


\subsubsection{Oracle logging repository}
\label{databaseLogging:oracle-logging-repository}
If the logging data is to be persisted in Oracle, the tables must be
created and some packages created.
\begin{enumerate}
\item {} 
job\_log

\item {} 
job\_msg

\item {} 
job step

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] The granularity of job step is left to the invoker.
\item[] As the overhead is very low, there is no reason to be parsimonious
\end{DUlineblock}

with identification, it's a simple one line call in the user app.

These records can be reviewed for job sucess or failure and form a
historical basis of time elapsed by job and step.

This may be used as a starting pointing in locating ``what processes are
using the time?''

Additionally they constitute a base performance metric from which
runtime degradation or periodic anomalous runs may be identified.

Data is committed by calls from java to the package logger, provided
here.

The package utilizes autonomous commits and hence may be safely called
using the same connection as the application.


\section{Oracle trace information}
\label{index:oracle-trace-information}
The third type of logging is an extension of database logging and stores
oracle trace information a relational database.

Oracle tracing is turned on and the trace files parsed and aggregated
and stored in tables associated with the various job steps.
\begin{itemize}
\item {} 
oracle

\item {} 
h2

\item {} 
postgresql

\end{itemize}


\chapter{Database logs}
\label{index:database-logs}
We will start with an example program and show what is logged.


\section{Java Example}
\label{index:java-example}
\begin{Verbatim}[commandchars=\\\{\}]
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
package org.javautil.dblogging;

import java.sql.Connection;
import java.sql.SQLException;

import org.javautil.core.sql.Binds;
import org.javautil.core.sql.ConnectionUtil;
import org.javautil.core.sql.SqlStatement;
import org.javautil.dblogging.logger.Dblogger;
import org.javautil.util.NameValue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DbloggerForOracleExample \PYGZob{}

    private Dblogger dblogger;
    private Connection connection;
    private String processName;
    private boolean testAbort = false;
    private int traceLevel;
    private final Logger logger = LoggerFactory.getLogger(getClass());

    public DbloggerForOracleExample(Connection connection, Dblogger dblogger, String processName, boolean testAbort,
            int traceLevel) \PYGZob{}
        this.connection = connection;
        this.dblogger = dblogger;
        this.processName = processName;
        this.testAbort = testAbort;
        this.traceLevel = traceLevel;
    \PYGZcb{}

    public long process() throws SQLException \PYGZob{}
        dblogger.prepareConnection();
        long id = 0;

        try \PYGZob{}
            id = dblogger.startJobLogging(processName, getClass().getName(), "ExampleLogging", null, 12);
            logger.debug("============================jobId: \PYGZob{}\PYGZcb{}", id);
            limitedFullJoin();
            fullJoin();
            userTablesCount();
            if (testAbort) \PYGZob{}
                int x = 1 / 0;
            \PYGZcb{}
            logger.debug("calling endJob");
            dblogger.endJob();
        \PYGZcb{} catch (Exception e) \PYGZob{}
            logger.error(e.getMessage());
            e.printStackTrace();
            dblogger.abortJob(e);
            throw e;
        \PYGZcb{}
        return id;
    \PYGZcb{}

    /**
     * This will set the v\$session.action
     */
    private void limitedFullJoin() throws SQLException \PYGZob{}
        logger.debug("limitedFullJoin =============");
        dblogger.setAction("actionNoStep");
        ConnectionUtil.exhaustQuery(connection, "select * from user\_tab\_columns, user\_tables where rownum \textless{} 200");
        dblogger.setAction(null);  // no longer performing that action, so clear
        logger.debug("limitedFullJoin complete =============");
    \PYGZcb{}

    private void fullJoin() throws SQLException \PYGZob{}
        logger.debug("fullJoinBegins =============");
        // TODO insertStep should set the action
        dblogger.insertStep("fullJoin", "fullJoin", getClass().getName());
        ConnectionUtil.exhaustQuery(connection, "select * from user\_tab\_columns, user\_tables");
        dblogger.finishStep();
        logger.debug("fullJoin complete =============");
    \PYGZcb{}

    private void userTablesCount() throws SQLException \PYGZob{}
        dblogger.insertStep("count full", "userTablesCount", getClass().getName());
        ConnectionUtil.exhaustQuery(connection, "select count(*) dracula from user\_tables");
        dblogger.finishStep();
        // TODO support implicit finish step
    \PYGZcb{}

    NameValue getJobLog(Connection connection, long id) throws SQLException \PYGZob{}
        final String sql = "select * from job\_log " + "where job\_log\_id = :job\_stat\_id";
        final SqlStatement ss = new SqlStatement(connection, sql);
        Binds binds = new Binds();
        binds.put("job\_stat\_id", id);
        final NameValue retval = ss.getNameValue();
        ss.close();
        return retval;
    \PYGZcb{}
\PYGZcb{}
\end{Verbatim}


\section{Analyzing the logs}
\label{index:analyzing-the-logs}
Separate utilities are used to analyzed the logs. A very useful tool is
javautil-condition-identification.

Did any job abort?

What is the trend on elapsed times?

How do elapsed times vary based on time of day?

Getting deeper, with trace information one can drill down to the
details, we will cover that later.


\chapter{Tracefile generation and persistence}
\label{index:tracefile-generation-and-persistence}
This utility provides the information to the Oracle Performance
specialist to identify the root cause of the problem, how to repair is
another speciality.


\chapter{Installation of database artifacts for oracle}
\label{index:installation-of-database-artifacts-for-oracle}
These files may be found under \emph{src/main/resources/ddl/oracle}

The script that runs them all is \emph{install.sql}

\begin{Verbatim}[commandchars=\\\{\}]
set echo on
@prepare\_connection.sql
@my\_session\_info.sql
@dblogger\_uninstall.sr.sql
@logger\_message\_formatter.plsql.sr.sql
@dblogger\_install\_tables.sr.sql
@dblogger\_install.pks.sr.sql
@dblogger\_install.pkb.sr.sql
@logger\_persistence.pks.sr.sql
@logger\_persistence.pkb.sr.sql
\end{Verbatim}


\section{prepare\_connnection}
\label{index:prepare-connnection}
\begin{DUlineblock}{0em}
\item[] prepare-connection provides one procedure.
\item[] This will call dbms\_session.clear\_context for each context variable,
\end{DUlineblock}

restoring the context for a connection returned from a connection\_pool
to the state the of an initially opened connection.

Connection pools do not generally clear this information out as it is
Oracle specific.


\section{my\_session\_info.sql}
\label{index:my-session-info-sql}
creates the view \emph{my\_session\_info} to allow the connected user to
obtain the v\$session record for the current connection.


\section{logger\_message\_formatter}
\label{index:logger-message-formatter}
Provides the \emph{logger\_message\_formatter} function, which creates a
single string from all of the logging parameters and makes a call to
dbms\_output.put\_line and then returns the formatted message.


\section{dblogger\_intall\_tables}
\label{index:dblogger-intall-tables}
Creates the job and job step tables and views

cursor\_info\_run\_id\_seq; cursor\_info\_id\_seq; job\_log\_id\_seq;
job\_msg\_id\_seq; job\_step\_id\_seq;
\begin{itemize}
\item {} 
cursor\_explain\_plan

\item {} 
cursor\_sql\_text

\item {} 
cursor\_info\_run

\item {} 
cursor\_info

\item {} 
cursor\_stat

\item {} 
job\_log

\item {} 
job\_msg

\item {} 
job\_step

\end{itemize}
\begin{itemize}
\item {} 
cursor\_info\_vw

\item {} 
job\_step\_vw

\item {} 
job\_log\_vw

\end{itemize}


\section{Job Logging}
\label{index:job-logging}
Logging information may be written to a text file, stored in a database
and written to the oracle trace file.


\subsection{Steps start job logging.}
\label{index:steps-start-job-logging}
\begin{Verbatim}[commandchars=\\\{\}]
public long sampleUsage(Dblogger dblogger, Connection appConnection) throws SqlSplitterException, Exception \PYGZob{}
    dblogger.prepareConnection();
    final String processName = "Process Name";
    // Start the job

    final long logJobId = dblogger.startJobLogging(processName,getClass().getName(), null, null,  4);
    dblogger.setModule("SplitLoggerTest", "simple example");
    dblogger.setAction("Some work");
    dblogger.insertStep("Full join", "Meaningless busy work", getClass().getName());
    ConnectionUtil.exhaustQuery(appConnection, "select * from user\_tab\_columns, user\_tables where rownum \textless{} 100");

    dblogger.setAction("Another set of work");
    ConnectionUtil.exhaustQuery(appConnection, "select count(*) from all\_tab\_columns");
    // End the job
    dblogger.endJob();
    return logJobId;
\PYGZcb{}
\end{Verbatim}

job logging persistence has a bit of indirection


\section{Installation}
\label{index:installation}

\subsection{Repositories}
\label{index:repositories}
RDBMS persistence support is provided for Oracle, H2 and postgresql

H2 is a lightweight database and may be used to eliminate the need for
support of another Oracle Database.

Postgresql is a high end database that requires minimimal installation
and administration.

You should probable not compound your problem with yet another Oracle
install, but if your DBA will allow you a schema in your database for
logging, you don't have to learn anything else.

The Oracle database could be the same instance as the application being
monitored, but this may raise some objections to the application DBA.


\subsection{Oracle logging repository}
\label{index:oracle-logging-repository}
If the logging data is to be persisted in Oracle, the tables must be
created and some packages created.


\subsubsection{Job log tables}
\label{index:job-log-tables}\begin{enumerate}
\item {} 
job\_log

\item {} 
job\_msg

\item {} 
job step

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] The granularity of job step is left to the invoker.
\item[] As the overhead is very low, there is no reason to be parsimonious
\end{DUlineblock}

with identification, it's a simple one line call in the user app.

These records can be reviewed for job sucess or failure and form a
historical basis of time elapsed.

This may be used as a starting pointing in locating ``what processes are
using the time?''

Additionally they constitute a base performance metric from which
runtime degradation or periodic anomalous runs may be identified.

Data is committed by calls from java to the package logger, provided
here.

The package creates autonomous commits and hence may be safely called
using the same connection as the application.


\subsection{logging package}
\label{index:logging-package}
The logger package provides the following:

\begin{Verbatim}[commandchars=\\\{\}]
These primarily set information in the SGA and enable oracle session tracing.
\end{Verbatim}

begin\_java\_java


\subsubsection{change v\$session information}
\label{index:change-v-session-information}
procedure prepare\_connection;

set\_module set action


\section{Trace Repository}
\label{index:trace-repository}\begin{itemize}
\item {} 
cursor\_explain\_plan

\item {} 
cursor\_sql\_text

\item {} 
cursor\_info\_run

\item {} 
cursor\_info

\item {} 
cursor\_stat

\end{itemize}


\section{logger\_persistence package}
\label{index:logger-persistence-package}
The logger persistence package provides an API for writing to various
tables using autonomous transactions.

\begin{Verbatim}[commandchars=\\\{\}]
procedure save\_job\_log (
    p\_job\_log\_id   in number,
    p\_schema\_name  in varchar2,
    p\_process\_name in varchar2,
    p\_classname    in varchar2,
    p\_module\_name  in varchar2,
    p\_status\_msg   in varchar2,
    p\_thread\_name  in varchar2,
    p\_trace\_level  in pls\_integer default logger.G\_INFO,
    p\_tracefile\_name in varchar2,
    p\_sid          in pls\_integer
);
\end{Verbatim}

The source of work is indentifable down to the java thread.

\begin{Verbatim}[commandchars=\\\{\}]
function save\_job\_step (
    p\_job\_log\_id  in pls\_integer,
    p\_step\_name   in varchar,
    p\_step\_info   in varchar,
    p\_classname   in varchar,
    p\_start\_ts    in timestamp,
    p\_stacktrace  in varchar
\end{Verbatim}

) return number;

\begin{Verbatim}[commandchars=\\\{\}]
procedure finish\_step

procedure end\_job(p\_elapsed\_milliseconds in pls\_integer)

procedure abort\_job(p\_elapsed\_milliseconds in pls\_integer,p\_stacktrace in varchar);
\end{Verbatim}


\subsection{Install Oracle JDBC}
\label{index:install-oracle-jdbc}
\href{https://blogs.oracle.com/dev2dev/get-oracle-jdbc-drivers-and-ucp-from-oracle-maven-repository-without-ides}{See this
post}
to use Oracle JDBC properly. Or, you could download the JAR file, and
then execute this command:

TODO the script to locatge
\code{mvn install:install-file -DgroupId=com.oracle -DartifactId=oracle-jdbc8 -Dversion=12c -Dpackaging=jar -Dfile=\textless{}THE\_JDBC\_JAR\_LOCATION\textgreater{}}

Notations in job .sql script used by sqlrunner.


\chapter{Security in production}
\label{index:security-in-production}

\chapter{User priviliges}
\label{index:user-priviliges}

\chapter{Performance}
\label{index:performance}

\chapter{Tools and concepts}
\label{index:tools-and-concepts}
User should be familiar with v\$ssession view, tkprof command line
utility


\chapter{Connection Pools}
\label{index:connection-pools}

\section{After Getting a connection}
\label{index:after-getting-a-connection}

\subsection{Contexts}
\label{index:contexts}
If a session is being used as part of a connection pool and the state of
its contexts are not reinitialized, this can lead to unexpected
behavior.


\subsection{Packages}
\label{index:packages}
Sessions have the ability to alter package state by amending the values
of package variables. If a session is being used as part of a connection
pool and the state of its packages are not reinitialized, this can lead
to unexpected behavior. To solve this, Oracle provides the
dbms\_session.reset\_package procedure.

The dbloggging provided procedure clears all context variables and
resets package state.

Connections must be reset immediately after being obtained from a
connection pool

In src/main/resources/ddl/oracle/prepare\_connection


\subsection{Convenience Procedure}
\label{index:convenience-procedure}
\begin{Verbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE prepare\_connection
AS
    context\_info DBMS\_SESSION.AppCtxTabTyp;
    info\_count PLS\_INTEGER;
    indx PLS\_INTEGER;
BEGIN
    DBMS\_SESSION.LIST\_CONTEXT ( context\_info, info\_count);
    indx := context\_info.FIRST;
    LOOP
        EXIT WHEN indx IS NULL;
        DBMS\_SESSION.CLEAR\_CONTEXT(
            context\_info(indx).namespace,
            context\_info(indx).attribute,
            null
        );
        indx := context\_info.NEXT (indx);
    END LOOP;
    DBMS\_SESSION.RESET\_PACKAGE;
END;
\end{Verbatim}

create public synonym prepare\_connection for prepare\_connection; grant
execute on prepare\_connection to public; {}`{}`{}`


\subsection{Zaxxer}
\label{index:zaxxer}
TODO how to call this procedure in the connection pool


\section{\#\# DBMS\_SESSION}
\label{index:dbms-session}

\section{Identifier}
\label{index:identifier}
SET\_IDENTIFIER and CLEAR\_IDENTIFIER procedures to allow the real user
to be associated with a session, regardless of what database user was
being used for the connection.


\section{Metrics}
\label{index:metrics}\begin{description}
\item[{try \{}] \leavevmode
String e2eMetrics{[}{]} = new
String{[}OracleConnection.END\_TO\_END\_STATE\_INDEX\_MAX{]};
e2eMetrics{[}OracleConnection.END\_TO\_END\_ACTION\_INDEX{]} = null;
e2eMetrics{[}OracleConnection.END\_TO\_END\_MODULE\_INDEX{]} = null;
e2eMetrics{[}OracleConnection.END\_TO\_END\_CLIENTID\_INDEX{]} = null;
((OracleConnection) conn).setEndToEndMetrics(e2eMetrics,
Short.MIN\_VALUE);

\item[{\} catch (SQLException sqle) \{}] \leavevmode
// Do something...

\end{description}

\}

0 - No trace. Like switching sql\_trace off. 2 - The equivalent of
regular sql\_trace. 4 - The same as 2, but with the addition of bind
variable values. 8 - The same as 2, but with the addition of wait
events. 12 - The same as 2, but with both bind variable values and wait
events.

Monitoring long running
\href{https://oracle-base.com/articles/11g/real-time-sql-monitoring-11gr1}{https://oracle-base.com/articles/11g/real-time-sql-monitoring-11gr1}

\# Database Objects
\begin{description}
\item[{\#\# Entity Relationship Diagram}] \leavevmode
logger\_tables.png

\end{description}

\#\# Table DDL

\#\#\# Oracle


\section{References}
\label{index:references}
!!{[}javadoc{]} (`../target/site/apidocs/index.html')

\href{https://oracle-base.com/articles/misc/dbms\_session}{https://oracle-base.com/articles/misc/dbms\_session}

\href{https://oracle-base.com/articles/misc/sql-trace-10046-trcsess-and-tkprof}{https://oracle-base.com/articles/misc/sql-trace-10046-trcsess-and-tkprof}
\begin{figure}[htbp]
\centering

\includegraphics{logger_tables.png}
\end{figure}


\chapter{Spring Developers}
\label{index:spring-developers}
Oracle tracing is a powerful tool that logs detailed information about
all calls to the Oracle database.

In order to use this :
\begin{itemize}
\item {} 
one must turn on tracing for the current connection

\item {} 
set the log file

\item {} 
stop tracing

\item {} 
call a service to store the trace

\item {} 
store the raw trace file

\item {} 
analyze the trace file

\item {} 
store the analyzed trace file

\end{itemize}

Logs messages using utl\_file to a directory on the database server
specified.

First the database directory is created and oracle is granted permission
to read and write it, then the ddl ``create directory....'' and ``grant
read, write on directory...''

\begin{Verbatim}[commandchars=\\\{\}]
set serveroutput on
set echo on
create or replace procedure log\_to\_file\_only is
       long\_msg clob := 'this is an absurdly long message, ' \textbar{}\textbar{}
                ' interesting stuff to say so I will just write meaningless ' \textbar{}\textbar{}
                ' stuff for a little while. ' \textbar{}\textbar{}
                ' The quick brown fox jumped over the lazy dog. ';

    my\_log\_file\_name varchar(4096);
begin
    my\_log\_file\_name := pllogger.open\_log\_file('log\_to\_file\_only.text');
    pllogger.set\_filter\_level(9); -- all messages should go to log file
    pllogger.info('anonymous',\$\$PLSQL\_LINE,'begin loop');
    pllogger.info(\$\$PLSQL\_UNIT,\$\$PLSQL\_LINE,long\_msg);
    for i in 1..3
    loop
        pllogger.fine(\$\$PLSQL\_UNIT,\$\$PLSQL\_LINE,'i is ' \textbar{}\textbar{} to\_char(i));
    end loop;
    pllogger.close\_log\_file();
exception when others then
        -- a severe condition is not necessarily fatal
    pllogger.severe(\$\$PLSQL\_UINIT,\$\$PLSQL\_LINE,sqlerrm);
    pllogger.close\_log\_file();
    raise;
end;
/
show errors

exec log\_to\_file\_only();
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
"log\_level","job\_log\_id","job\_msg\_id","line\_number","timestamp","log\_msg","caller\_name","call\_stack"
4,,,17,"2019-10-26T17:19:52.885607","begin loop","anonymous",""
4,,,18,"2019-10-26T17:19:52.886020","this is an absurdly long message,  exceeding the length of the log\_msg field  this should be inserted into the log\_msg\_clob column.   This message is part of  a unit test of from sample\_job\_02 of the logging package.   I am running out of  interesting stuff to say so I will just write meaningless  stuff for a little while.  The quick brown fox jumped over the lazy dog. ","LOG\_TO\_FILE\_ONLY",""
7,,,22,"2019-10-26T17:19:52.886197","i is 1","LOG\_TO\_FILE\_ONLY",""
7,,,22,"2019-10-26T17:19:52.886357","i is 2","LOG\_TO\_FILE\_ONLY",""
7,,,22,"2019-10-26T17:19:52.886502","i is 3","LOG\_TO\_FILE\_ONLY",""
\end{Verbatim}


\chapter{TODO}
\label{index:todo}
Tracing should do the following
\begin{itemize}
\item {} 
Begin with any transaction as annotated by @Transactional

\end{itemize}


\chapter{Install}
\label{index:install}
\begin{Verbatim}[commandchars=\\\{\}]
cd src/main/resources/ddl/oracle

sqlplus \$ORACLE\_UID @ pllogger.pkgs.sr.sql
sqlplus \$ORACLE\_UID @ pllogger.pkgb.sr.sql
\end{Verbatim}

create directory job\_msg\_dir as
`/common/scratch/ut\_process\_log\_dir'; grant write on directory to sr;

should be granted by user, not by role.
\begin{itemize}
\item {} 
Configuring to use your database

\item {} 
Example schema

\end{itemize}


\chapter{Trace file fields}
\label{index:trace-file-fields}

\section{Trace Record Fields}
\label{traceRecordFields:trace-record-fields}\label{traceRecordFields::doc}
code-block:

\begin{Verbatim}[commandchars=\\\{\}]
                                       Cursor Operation
           Type     Parsing ParseError Parse EXec Fetch Stat  Lobread Lobpgsize Close
\&\#35;  cursorNumbe             X                X    X   X
ad     sgaAddress      X
bytes  bytes                                                     X      X
c      CpuMicroSec                        X     X    X           X      X         X
card   cardinality
cnt                                                      O
cost   cost (optim
cr     consistentR                        X     X    X           X      X
cu     currentMode                        X     X    X           X      X
dep    depth           X       X          X     X    X                            X
e      elapsedMicr                        X     X    X           X      X         X
err    oracleError             X
hv     sqlHashValu     X
id                                                       X
len    sqlTeXtLeng     X       X
lid                    X       X
mis    libraryCach                        X     X    X
obj    objectNumbe                                       X
oct    oracleComma     X       X
og     optimizerGo                        X     X    X
op     operation                                           X
p      physicalBlo                        X     X    X              X       X
pid    processId                                           X
plh                                       X     X    X
pos    position (o                                         X
pw     physicalWri                                         X
r      rowCount                           X     X    X
size                                                       O
sqlid  sqlId           X
str                                                                 X
tim                                       X     X    X              X       X        X
time
type                                                                                                          X
uid                    X      X
\end{Verbatim}


\chapter{TODO}
\label{index:id1}\begin{itemize}
\item {} 
security can't specify file name

\item {} 
need an agent to get the log files for remote users

\item {} 
TODO escape double quotes in text fields

\item {} 
check for anomolous run-times using condition identification

\item {} 
plot runtimes

\item {} 
TODO describe microservices, multiple connections, tying them all
together

\item {} 
TODO describe using with spring

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
